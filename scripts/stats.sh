#!/bin/bash
#
# Print stats about Parameter Server benchmark experiments
#
# title         stats.sh
# author        Luis Mateos (luismattor@gmail.com)
# date          11-08-2015
# usage         ./update-stats.sh experiment-file
# notes			Ensure experiment files generated by benchmarks exist on local and remote nodes.
#

set -e

declare -a nodes=("mercado-10" "mercado-11" "mercado-12" "mercado-13" "mercado-19")

# Print average, max and min for a given metric.
# param $1	metric description (echoed to console)
# param $2	metric keyword in log file (used by grep to find metric)
# param $3	specifies the scan type, 0 - read all records; 1 - read all but first; 2 - read all but last
# param $4	metrics log file
function print_metric_stats() {
	local description=$1
	local keyword=$2
	local scan_type=$3
	local file=$4

	n_records=$(grep "$keyword" $file | wc -l)
	#echo "Found $n_records for metric $keyword"
	case "$scan_type" in
	0)
		# Consider all records
		metric=$(grep "$keyword" $file | cut -f 3 | awk '{ total += $1 } END { printf "%.6f", total/NR }')
		metric_max=$(grep "$keyword" $file | cut -f 3 | awk 'max=="" || $1 > max {max=$1} END{print max}')
		metric_min=$(grep "$keyword" $file| cut -f 3 | awk 'min=="" || $1 < min {min=$1} END{print min}')
		;;
	1)
		# Consider all but first record
		if [ $n_records -gt 1 ]
		then
			metric=$(grep $keyword $file | tail -n +2 | cut -f 3 | awk '{ total += $1 } END { printf "%.6f", total/NR }')
			metric_max=$(grep $keyword $file | tail -n +2 | cut -f 3 | awk 'max=="" || $1 > max {max=$1} END{print max}')
			metric_min=$(grep $keyword $file | tail -n +2 | cut -f 3 | awk 'min=="" || $1 < min {min=$1} END{print min}')
		fi
		;;
	2)
		# Consider all but last record
		if [ $n_records -gt 1 ]
		then
			metric=$(grep $keyword $file | head -n -1 | cut -f 3 | awk '{ total += $1 } END { printf "%.6f", total/NR }')
			metric_max=$(grep $keyword $file | head -n -1 | cut -f 3 | awk 'max=="" || $1 > max {max=$1} END{print max}')
			metric_min=$(grep $keyword $file | head -n -1 | cut -f 3 | awk 'min=="" || $1 < min {min=$1} END{print min}')
		fi
		;;
	esac
	echo "$description: $metric, $metric_min, $metric_max"
}

# Prints stats about PS related tasks on Spark executors.
# param $1 	the log file retrieved from an spark executor created by a particular experiment
# param $2	the executor name (for logging purposes)
function print_ps_executor_stats() {
	echo "=================================="
	echo "Computing experiment stats for executors"

	# Time that a client takes to get params from PS
	# print_metric_stats "PS client read time        [s]" "PS read" 0 $1
	# Time that a client takes to update params to PS
	# print_metric_stats "PS client write time       [s]" "PS write" 0 $1
	# Time that a client takes to create the delta that wil be uploaded to PS
	# print_metric_stats "PS client create delta time[s]" "Delta" 0 $1

	# Time for creating an array from a iterator
	print_metric_stats "Cast iterator into array   [s]" "ps-toarray" 0 $1

	# Time for creating a PS client (blocking operation)
	print_metric_stats "Create client time         [s]" "ps-create-client" 0 $1

	# Time for executing the PS function (non-blocking operation)
	print_metric_stats "Client function time       [s]" "ps-function" 0 $1

	# Time for creating the param delta
	print_metric_stats "Client delta time          [s]" "ps-delta" 0 $1

	# Time for stoping PS client (non-blocking operation)
	print_metric_stats "Stop client time           [s]" "ps-stop-client" 0 $1

	# Round-trip delay time for sending params to PS
	print_metric_stats "Updating params trip time  [s]" "ps-net-update" 1 $1

	# Round-trip delay time for unregister client from server
	print_metric_stats "Unregister client trip time[s]" "ps-net-remove" 0 $1
}

# Prints stats about PS related tasks on Spark driver
# param $1 	the results file generated by a particular experiment
function print_ps_driver_stats() {
	echo "=================================="
	echo "Computing experiment stats for driver"

	nchunks=$(csplit $1 /-----/ {*} | wc -l)
	chunkid=$(($nchunks - 1))
	chunk=$(dirname "${input}")/xx0"$chunkid"

	# Time for getting params from PS
	print_metric_stats "Getting params total time  [s]" "ps-get" 1 $chunk

	# Time for broadcasting params to PS clients
	print_metric_stats "Broadcasting params time   [s]" "ps-broadcast" 0 $chunk

	# Time for executing PS job
	print_metric_stats "PS job execution time      [s]" "ps-job" 0 $chunk

	# Time for performing vector update on server
	print_metric_stats "Server vector update time  [s]" "ps-vector-update" 1 $chunk

	# Round-trip delay time for getting params from server
	print_metric_stats "Getting params trip time   [s]" "ps-net-get" 2 $chunk

	rm $(dirname "${input}")/xx*
}

function compute_stats_cluster() {
	# Getting experiment results from executors
	# Deleting previous metrics file
	node_file=tmp.txt
	acc_file=stats.log
	if [ -s $acc_file ]; then
		rm $acc_file
	fi
	# Appending outputs of each experiment to metrics file
	for node in "${nodes[@]}"
	do
		executorip=hduser@$node
		executorid=$(ssh $executorip "ls $remotedir")
		scp $executorip:$remotedir/$executorid/stdout $node_file > /dev/null
		if [ -s $node_file ]; then
			echo "Appending file for node " $node
			cat $node_file >> $acc_file
		fi
		rm $node_file
	done
	# Prints benchmark results stats for executors
	print_ps_executor_stats $acc_file
	# Prints benchmark results stats for driver
	print_ps_driver_stats $1
	# Print update average
	echo "=================================="
	echo "PS total iteration time    [s]:" $(grep "average" $1 | awk 'NF>1{print $NF}')
}

function compute_stats_local() {
	print_ps_executor_stats $1
	print_ps_driver_stats $1
	echo "=================================="
	echo "PS total iteration time    [s]:" $(grep "average" $1 | awk 'NF>1{print $NF}')
}

# Read app ID from experiment file
appid=$(grep "Application ID" $2 | awk 'NF>1{print $NF}')
# Experiment log file location on executors
remotedir=/usr/local/spark-ps/work/$appid

echo "Computing benchmark experiments stats for app $appid "
echo "$(date)"

case $1 in
	cluster) compute_stats_cluster $2 ;;
	local) compute_stats_local $2 ;;
	*) echo "Unkown command $1"
esac

